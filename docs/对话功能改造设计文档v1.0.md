# 对话功能改造设计文档

## 1. 设计目标

根据参考流程图，改造对话功能，实现以下目标：

1. **架构设计**：采用四层级架构（前端、后端服务、智能体服务、数据存储层）
2. **实时推送**：使用SSE（Server-Sent Events）技术实时推送模型输出的消息给前端
3. **消息传递**：后端服务和智能体服务之间使用队列形式实现消息传递
4. **数据存储**：使用Redis服务存储会话信息，默认保存7天的历史对话
5. **UI改造**：在对话页面Social.Vue的左边一列显示历史对话的行内容

## 2. 架构设计

### 2.1 整体架构

```
前端 <--> 后端服务 <--> 智能体服务 <--> 数据存储层（Redis）
```

### 2.2 数据流

1. **用户输入**：前端发送用户消息到后端服务
2. **消息处理**：后端服务将消息存入Redis，然后通过队列发送给智能体服务
3. **智能体处理**：智能体服务处理消息，生成响应
4. **响应回传**：智能体服务将响应通过队列传回后端服务
5. **实时推送**：后端服务通过SSE将响应实时推送给前端
6. **状态同步**：实时同步对话状态和中间数据

## 3. 技术选型

| 组件 | 技术 | 版本 | 用途 |
|------|------|------|------|
| 前端 | Vue 3 | ^3.2.0 | 前端框架 |
| 后端 | FastAPI | ^0.104.0 | 后端API框架 |
| 智能体 | Python | ^3.9.0 | 智能体服务 |
| 队列 | Redis Stream | - | 消息队列 |
| 存储 | Redis | ^7.0.0 | 会话存储 |
| 实时通信 | SSE | - | 服务器推送事件 |

## 4. 数据结构设计

### 4.1 Redis存储结构

| 键名 | 类型 | 说明 | 过期时间 |
|------|------|------|----------|
| `session:{session_id}` | Hash | 会话基本信息 | 7天 |
| `session:{session_id}:messages` | List | 会话消息列表 | 7天 |
| `session:{session_id}:context` | Hash | 会话上下文 | 7天 |
| `queue:dialog:in` | Stream | 入队消息 | 24小时 |
| `queue:dialog:out` | Stream | 出队消息 | 24小时 |

### 4.2 消息格式

#### 入队消息（后端 → 智能体）

```json
{
  "session_id": "string",
  "user_id": "number",
  "message": "string",
  "timestamp": "string",
  "context": "object"
}
```

#### 出队消息（智能体 → 后端）

```json
{
  "session_id": "string",
  "user_id": "number",
  "message": "string",
  "intent": "string",
  "suggestions": "array",
  "timestamp": "string"
}
```

#### SSE消息格式

```json
{
  "type": "message",
  "session_id": "string",
  "message": "string",
  "intent": "string",
  "suggestions": "array"
}
```

## 5. 接口设计

### 5.1 前端接口

| 接口 | 方法 | 功能 |
|------|------|------|
| `/api/dialog/chat` | POST | 发送消息 |
| `/api/dialog/sessions` | GET | 获取会话列表 |
| `/api/dialog/sessions/{session_id}` | GET | 获取会话详情 |
| `/api/dialog/sessions/{session_id}` | DELETE | 删除会话 |
| `/api/dialog/sse/{session_id}` | GET | SSE实时连接 |

### 5.2 后端内部接口

| 接口 | 方法 | 功能 |
|------|------|------|
| `/internal/agent/poll` | GET | 智能体轮询消息 |
| `/internal/agent/response` | POST | 智能体返回响应 |

## 6. 前端实现

### 6.1 Social.Vue改造

1. **左侧历史对话列表**：
   - 显示用户的历史对话会话
   - 每个会话显示标题和消息数量
   - 支持点击切换会话
   - 支持删除会话

2. **右侧对话区域**：
   - 显示当前会话的消息列表
   - 支持发送新消息
   - 支持实时接收消息（SSE）

3. **SSE连接管理**：
   - 建立SSE连接
   - 处理实时消息
   - 重连机制

### 6.2 代码示例

```vue
<template>
  <div class="social-page">
    <!-- 顶部导航栏 -->
    <div class="top-header">
      <!-- 现有代码 -->
    </div>

    <!-- 主内容区 -->
    <div class="main-content">
      <!-- 左侧历史对话列表 -->
      <div class="content-left">
        <div class="history-sessions">
          <h3>历史对话</h3>
          <a-list :data-source="sessions" :loading="loadingSessions">
            <template #renderItem="{ item }">
              <a-list-item
                :class="{ active: item.id === currentSessionId }"
                @click="selectSession(item.id)"
                style="cursor: pointer"
              >
                <a-list-item-meta>
                  <template #title>{{ item.title }}</template>
                  <template #description>{{ item.message_count }} 条消息</template>
                </a-list-item-meta>
                <template #actions>
                  <a-button type="text" danger size="small" @click.stop="deleteSession(item.id)">
                    <DeleteOutlined />
                  </a-button>
                </template>
              </a-list-item>
            </template>
          </a-list>
        </div>
      </div>

      <!-- 右侧对话区域 -->
      <div class="content-right">
        <div class="chat-container">
          <div class="messages-container" ref="messagesRef">
            <div v-for="msg in messages" :key="msg.id" :class="['message', msg.role]">
              <div class="message-content">
                <a-avatar v-if="msg.role === 'user'" style="background-color: #1890ff">
                  <UserOutlined />
                </a-avatar>
                <a-avatar v-else style="background-color: #52c41a">
                  <RobotOutlined />
                </a-avatar>
                <div class="message-text">{{ msg.content }}</div>
              </div>
            </div>
          </div>

          <div class="input-container">
            <a-input-search
              v-model:value="inputMessage"
              placeholder="输入消息..."
              :loading="sending"
              @search="sendMessage"
              size="large"
            >
              <template #enterButton>
                <a-button type="primary">
                  <SendOutlined />
                </a-button>
              </template>
            </a-input-search>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, nextTick, watch } from 'vue'
import { useRouter } from 'vue-router'
import { message } from 'ant-design-vue'
import { 
  DeleteOutlined, 
  UserOutlined, 
  RobotOutlined, 
  SendOutlined,
  LeftOutlined
} from '@ant-design/icons-vue'
import { dialogService } from '@/services/dialog'

const router = useRouter()

// 状态管理
const sessions = ref<any[]>([])
const messages = ref<any[]>([])
const currentSessionId = ref<string | null>(null)
const loadingSessions = ref(false)
const sending = ref(false)
const inputMessage = ref('')
const messagesRef = ref<HTMLElement>()
let eventSource: EventSource | null = null

onMounted(async () => {
  await loadSessions()
})

onUnmounted(() => {
  if (eventSource) {
    eventSource.close()
  }
})

// 加载会话列表
async function loadSessions() {
  loadingSessions.value = true
  try {
    const result = await dialogService.getSessions()
    sessions.value = result.sessions || []
    if (sessions.value.length > 0 && !currentSessionId.value) {
      await selectSession(sessions.value[0].id)
    }
  } catch (error: any) {
    console.error('加载会话失败:', error)
    message.error('加载会话失败')
  } finally {
    loadingSessions.value = false
  }
}

// 选择会话
async function selectSession(sessionId: string) {
  currentSessionId.value = sessionId
  try {
    const session = await dialogService.getSession(sessionId)
    messages.value = session.messages || []
    connectSSE(sessionId)
    await nextTick()
    scrollToBottom()
  } catch (error) {
    message.error('加载消息失败')
  }
}

// 删除会话
async function deleteSession(sessionId: string) {
  try {
    await dialogService.deleteSession(sessionId)
    sessions.value = sessions.value.filter(s => s.id !== sessionId)
    if (currentSessionId.value === sessionId) {
      currentSessionId.value = null
      messages.value = []
      if (eventSource) {
        eventSource.close()
      }
    }
    message.success('删除成功')
  } catch (error) {
    message.error('删除失败')
  }
}

// 建立SSE连接
function connectSSE(sessionId: string) {
  if (eventSource) {
    eventSource.close()
  }

  eventSource = new EventSource(`/api/dialog/sse/${sessionId}`)

  eventSource.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data)
      if (data.type === 'message') {
        messages.value.push({
          id: Date.now().toString(),
          role: 'assistant',
          content: data.message,
          timestamp: new Date().toISOString()
        })
        scrollToBottom()
      }
    } catch (error) {
      console.error('SSE消息解析失败:', error)
    }
  }

  eventSource.onerror = () => {
    console.error('SSE连接错误')
  }
}

// 发送消息
async function sendMessage() {
  if (!inputMessage.value.trim() || !currentSessionId.value) return

  const userMessage = inputMessage.value
  inputMessage.value = ''
  sending.value = true

  try {
    // 添加用户消息到本地
    messages.value.push({
      id: Date.now().toString(),
      role: 'user',
      content: userMessage,
      timestamp: new Date().toISOString()
    })
    scrollToBottom()

    // 发送消息到后端
    await dialogService.chat(currentSessionId.value, { message: userMessage })
  } catch (error) {
    message.error('发送消息失败')
  } finally {
    sending.value = false
  }
}

// 滚动到底部
function scrollToBottom() {
  nextTick(() => {
    if (messagesRef.value) {
      messagesRef.value.scrollTop = messagesRef.value.scrollHeight
    }
  })
}
</script>

<style scoped>
/* 现有样式 */

/* 新增样式 */
.history-sessions {
  background: #fff;
  border-radius: 12px;
  padding: 20px;
  height: calc(100vh - 120px);
  overflow-y: auto;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
}

.history-sessions h3 {
  margin-top: 0;
  margin-bottom: 16px;
  font-size: 18px;
  font-weight: 600;
  color: #262626;
}

.chat-container {
  background: #fff;
  border-radius: 12px;
  height: calc(100vh - 120px);
  display: flex;
  flex-direction: column;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
}

.messages-container {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  background: #f5f5f5;
}

.message {
  margin-bottom: 16px;
}

.message-content {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.message.user .message-content {
  flex-direction: row-reverse;
}

.message-text {
  max-width: 60%;
  padding: 12px 16px;
  border-radius: 8px;
  background: white;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.message.user .message-text {
  background: #1890ff;
  color: white;
}

.input-container {
  padding: 16px;
  background: white;
  border-top: 1px solid #f0f0f0;
}

.active {
  background-color: #e6f7ff;
}
</style>
```

### 6.3 前端服务层改造

```typescript
// src/services/dialog.ts
import axios from '@/utils/axios'

interface CreateSessionResponse {
  session_id: string
  created_at: string
}

interface ChatRequest {
  message: string
}

interface ChatResponse {
  session_id: string
  message: string
  intent: string
  suggestions: string[]
}

interface Session {
  id: string
  title: string
  created_at: string
  updated_at: string
  message_count: number
}

interface Message {
  id: string
  role: 'user' | 'assistant'
  content: string
  timestamp: string
  tool_calls?: any[]
}

export const dialogService = {
  async createSession(): Promise<CreateSessionResponse> {
    try {
      const response = await axios.post('/api/dialog/sessions', {
        initial_context: {}
      })
      return response.data
    } catch (error: any) {
      console.error('[Dialog] 创建会话失败:', error)
      throw error
    }
  },

  async chat(sessionId: string, data: ChatRequest): Promise<ChatResponse> {
    try {
      const response = await axios.post('/api/dialog/chat', {
        session_id: sessionId,
        message: data.message
      })
      return response.data
    } catch (error: any) {
      console.error('[Dialog] 发送消息失败:', error)
      throw error
    }
  },

  async getSessions(): Promise<any> {
    try {
      const response = await axios.get('/api/dialog/sessions')
      return response.data
    } catch (error: any) {
      console.error('[Dialog] 获取会话列表失败:', error)
      throw error
    }
  },

  async getSession(sessionId: string): Promise<any> {
    try {
      const response = await axios.get(`/api/dialog/sessions/${sessionId}`)
      return response.data
    } catch (error: any) {
      console.error('[Dialog] 获取会话详情失败:', error)
      throw error
    }
  },

  async deleteSession(sessionId: string): Promise<void> {
    try {
      await axios.delete(`/api/dialog/sessions/${sessionId}`)
    } catch (error: any) {
      console.error('[Dialog] 删除会话失败:', error)
      throw error
    }
  }
}
```

## 7. 后端实现

### 7.1 后端API改造

```python
# app/api/routes/dialog.py
"""
对话管理路由

提供以下API：
- POST /api/dialog/chat - 多轮对话接口
- GET /api/dialog/sessions - 列出对话会话
- GET /api/dialog/sessions/{session_id} - 获取会话历史
- DELETE /api/dialog/sessions/{session_id} - 删除会话
- GET /api/dialog/sse/{session_id} - SSE实时对话
"""

from typing import Optional, List
from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.responses import StreamingResponse
from pydantic import BaseModel, Field
from loguru import logger
import json
import asyncio

from ...services.dialog_service import get_dialog_service
from ...middleware.auth_middleware import get_current_user, CurrentUser


router = APIRouter(prefix="/dialog", tags=["对话管理"])


# ========== 请求/响应模型 ==========

class ChatRequest(BaseModel):
    """对话请求"""
    session_id: Optional[str] = Field(None, description="会话ID（可选，不提供则创建新会话）")
    message: str = Field(..., description="用户消息")
    voice_data: Optional[str] = Field(None, description="语音数据（Base64编码，可选）")


class ChatResponse(BaseModel):
    """对话响应"""
    session_id: str = Field(..., description="会话ID")
    message: str = Field(..., description="助手回复")
    intent: str = Field(..., description="识别的意图")
    suggestions: List[str] = Field(default=[], description="建议回复")


class SessionListResponse(BaseModel):
    """会话列表响应"""
    total: int = Field(..., description="总数")
    sessions: List[dict] = Field(..., description="会话列表")


class SessionDetailResponse(BaseModel):
    """会话详情响应"""
    session_id: str = Field(..., description="会话ID")
    user_id: int = Field(..., description="用户ID")
    context: dict = Field(..., description="会话上下文")
    message_count: int = Field(..., description="消息数量")
    messages: List[dict] = Field(..., description="消息列表")
    created_at: str = Field(..., description="创建时间")
    updated_at: str = Field(..., description="更新时间")


class MessageResponse(BaseModel):
    """通用消息响应"""
    message: str = Field(..., description="消息内容")


class CreateSessionRequest(BaseModel):
    """创建会话请求"""
    initial_context: dict = Field(default={}, description="初始上下文")


class CreateSessionResponse(BaseModel):
    """创建会话响应"""
    session_id: str = Field(..., description="会话ID")
    message: str = Field(..., description="消息")


# ========== API端点 ==========

@router.post("/chat", response_model=ChatResponse)
async def chat(
    request: ChatRequest,
    current_user: CurrentUser = Depends(get_current_user)
):
    """
    多轮对话接口

    支持：
    - 自动创建新会话或使用现有会话
    - 意图识别和智能路由
    - 上下文理解
    - 工具调用日志记录
    """
    try:
        dialog_service = get_dialog_service()

        # 如果没有提供session_id，创建新会话
        session_id = request.session_id
        if not session_id:
            session_id = await dialog_service.create_session(
                user_id=current_user.id,
                initial_context={}
            )
            logger.info(f"创建新会话: {session_id} (用户: {current_user.username})")

        # 处理对话
        response = await dialog_service.process_message(
            session_id=session_id,
            user_id=current_user.id,
            user_message=request.message
        )

        logger.info(f"对话处理完成: {session_id} (意图: {response['intent']})")

        return ChatResponse(**response)

    except Exception as e:
        logger.error(f"对话处理失败: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"对话处理失败: {str(e)}"
        )


@router.post("/sessions", response_model=CreateSessionResponse)
async def create_session(
    request: CreateSessionRequest = CreateSessionRequest(),
    current_user: CurrentUser = Depends(get_current_user)
):
    """
    创建新的对话会话

    用于手动创建会话，通常在开始新对话时调用
    """
    try:
        dialog_service = get_dialog_service()

        session_id = await dialog_service.create_session(
            user_id=current_user.id,
            initial_context=request.initial_context
        )

        logger.info(f"创建新会话: {session_id} (用户: {current_user.username})")

        return CreateSessionResponse(
            session_id=session_id,
            message="会话创建成功"
        )

    except Exception as e:
        logger.error(f"创建会话失败: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"创建会话失败: {str(e)}"
        )


@router.get("/sessions", response_model=SessionListResponse)
async def list_sessions(
    is_active: Optional[bool] = None,
    limit: int = 20,
    skip: int = 0,
    current_user: CurrentUser = Depends(get_current_user)
):
    """
    列出用户的对话会话

    支持按活跃状态筛选和分页
    """
    try:
        dialog_service = get_dialog_service()

        sessions = await dialog_service.list_user_sessions(
            user_id=current_user.id,
            is_active=is_active,
            limit=limit,
            skip=skip
        )

        return SessionListResponse(
            total=len(sessions),
            sessions=sessions
        )

    except Exception as e:
        logger.error(f"列出会话失败: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="列出会话失败"
        )


@router.get("/sessions/{session_id}", response_model=SessionDetailResponse)
async def get_session_detail(
    session_id: str,
    current_user: CurrentUser = Depends(get_current_user)
):
    """
    获取会话详情

    包含会话信息和消息历史
    """
    try:
        dialog_service = get_dialog_service()

        # 获取会话上下文
        context = await dialog_service.get_session_context(session_id)

        if not context:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="会话不存在"
            )

        # 验证权限
        if context["user_id"] != current_user.id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="无权访问此会话"
            )

        return SessionDetailResponse(**context)

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"获取会话详情失败: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="获取会话详情失败"
        )


@router.delete("/sessions/{session_id}", response_model=MessageResponse)
async def delete_session(
    session_id: str,
    current_user: CurrentUser = Depends(get_current_user)
):
    """
    删除会话

    只能删除自己的会话
    """
    try:
        dialog_service = get_dialog_service()

        success = await dialog_service.delete_session(
            session_id=session_id,
            user_id=current_user.id
        )

        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="会话不存在"
            )

        logger.info(f"会话已删除: {session_id} (用户: {current_user.username})")

        return MessageResponse(message="会话已删除")

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"删除会话失败: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="删除会话失败"
        )


@router.get("/sse/{session_id}")
async def sse_endpoint(
    session_id: str,
    current_user: CurrentUser = Depends(get_current_user)
):
    """
    SSE实时对话端点

    支持：
    - 服务器推送事件
    - 实时消息传递
    - 会话状态同步
    """
    try:
        dialog_service = get_dialog_service()

        # 验证会话权限
        context = await dialog_service.get_session_context(session_id)
        if not context or context["user_id"] != current_user.id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="无权访问此会话"
            )

        async def event_generator():
            while True:
                # 检查是否有新消息
                message = await dialog_service.get_next_message(session_id)
                if message:
                    yield f"data: {json.dumps(message)}\n\n"
                await asyncio.sleep(0.1)

        return StreamingResponse(
            event_generator(),
            media_type="text/event-stream"
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"SSE端点错误: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="SSE端点错误"
        )
```

### 7.2 对话服务改造

```python
# app/services/dialog_service.py
"""
对话服务

负责：
- 会话管理
- 消息处理
- Redis存储
- 队列操作
"""

import json
import asyncio
import uuid
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any
from loguru import logger

from ..database.redis_client import get_redis_client


class DialogService:
    def __init__(self):
        self.redis = get_redis_client()
        self.message_queue = "queue:dialog:in"
        self.response_queue = "queue:dialog:out"
        self.session_ttl = 7 * 24 * 60 * 60  # 7天

    async def create_session(self, user_id: int, initial_context: dict = None) -> str:
        """创建新会话"""
        session_id = str(uuid.uuid4())
        now = datetime.now().isoformat()

        # 存储会话基本信息
        await self.redis.hset(
            f"session:{session_id}",
            mapping={
                "user_id": str(user_id),
                "created_at": now,
                "updated_at": now,
                "message_count": "0",
                "title": "新对话"
            }
        )

        # 设置过期时间
        await self.redis.expire(f"session:{session_id}", self.session_ttl)

        # 初始化消息列表
        await self.redis.expire(f"session:{session_id}:messages", self.session_ttl)

        # 存储初始上下文
        if initial_context:
            await self.redis.hset(
                f"session:{session_id}:context",
                mapping=initial_context
            )
            await self.redis.expire(f"session:{session_id}:context", self.session_ttl)

        return session_id

    async def process_message(self, session_id: str, user_id: int, user_message: str) -> Dict[str, Any]:
        """处理用户消息"""
        # 验证会话存在
        if not await self.redis.exists(f"session:{session_id}"):
            raise ValueError("会话不存在")

        # 验证用户权限
        stored_user_id = await self.redis.hget(f"session:{session_id}", "user_id")
        if str(user_id) != stored_user_id:
            raise ValueError("无权访问此会话")

        # 更新会话时间
        now = datetime.now().isoformat()
        await self.redis.hset(f"session:{session_id}", "updated_at", now)

        # 添加用户消息到历史
        user_message_data = {
            "id": str(uuid.uuid4()),
            "role": "user",
            "content": user_message,
            "timestamp": now
        }
        await self.redis.lpush(f"session:{session_id}:messages", json.dumps(user_message_data))
        await self.redis.hincrby(f"session:{session_id}", "message_count", 1)

        # 获取会话上下文
        context = await self._get_session_context(session_id)

        # 发送消息到队列
        queue_message = {
            "session_id": session_id,
            "user_id": user_id,
            "message": user_message,
            "timestamp": now,
            "context": context
        }

        await self.redis.xadd(
            self.message_queue,
            queue_message,
            maxlen=1000,
            approximate=True
        )

        # 等待智能体响应
        response = await self._wait_for_response(session_id)

        # 添加助手消息到历史
        assistant_message_data = {
            "id": str(uuid.uuid4()),
            "role": "assistant",
            "content": response["message"],
            "timestamp": datetime.now().isoformat()
        }
        await self.redis.lpush(f"session:{session_id}:messages", json.dumps(assistant_message_data))
        await self.redis.hincrby(f"session:{session_id}", "message_count", 1)

        # 更新会话标题（使用第一条消息作为标题）
        if await self.redis.hget(f"session:{session_id}", "title") == "新对话":
            title = user_message[:20] + "..." if len(user_message) > 20 else user_message
            await self.redis.hset(f"session:{session_id}", "title", title)

        return response

    async def _wait_for_response(self, session_id: str, timeout: int = 30) -> Dict[str, Any]:
        """等待智能体响应"""
        start_time = datetime.now()
        while (datetime.now() - start_time).total_seconds() < timeout:
            # 从响应队列获取消息
            messages = await self.redis.xread(
                {self.response_queue: "0"},
                count=1,
                block=1000
            )

            for stream, message_list in messages:
                for message_id, message_data in message_list:
                    # 解析消息
                    response = {
                        "session_id": message_data.get(b"session_id", b"").decode(),
                        "message": message_data.get(b"message", b"").decode(),
                        "intent": message_data.get(b"intent", b"").decode(),
                        "suggestions": json.loads(message_data.get(b"suggestions", b"[]").decode())
                    }

                    # 检查是否是当前会话的响应
                    if response["session_id"] == session_id:
                        # 确认消息
                        await self.redis.xdel(self.response_queue, message_id)
                        return response

            await asyncio.sleep(0.1)

        raise TimeoutError("等待智能体响应超时")

    async def get_next_message(self, session_id: str) -> Optional[Dict[str, Any]]:
        """获取下一条消息（用于SSE）"""
        # 这里可以实现一个消息缓冲区，或者直接从Redis获取最新消息
        # 简化实现：返回空，实际应该从缓冲区获取
        return None

    async def list_user_sessions(self, user_id: int, is_active: Optional[bool] = None, limit: int = 20, skip: int = 0) -> List[Dict[str, Any]]:
        """列出用户的会话"""
        sessions = []
        cursor = 0

        while True:
            cursor, keys = await self.redis.scan(cursor, match="session:*", count=100)
            for key in keys:
                key_str = key.decode()
                if key_str.endswith(":messages") or key_str.endswith(":context"):
                    continue

                # 获取会话信息
                session_info = await self.redis.hgetall(key_str)
                if not session_info:
                    continue

                # 验证用户权限
                stored_user_id = session_info.get(b"user_id", b"").decode()
                if str(user_id) != stored_user_id:
                    continue

                # 构建会话对象
                session_id = key_str.split(":")[1]
                session = {
                    "id": session_id,
                    "title": session_info.get(b"title", b"新对话").decode(),
                    "created_at": session_info.get(b"created_at", b"").decode(),
                    "updated_at": session_info.get(b"updated_at", b"").decode(),
                    "message_count": int(session_info.get(b"message_count", b"0").decode())
                }

                sessions.append(session)

            if cursor == 0:
                break

        # 按更新时间排序
        sessions.sort(key=lambda x: x["updated_at"], reverse=True)

        # 分页
        return sessions[skip:skip + limit]

    async def get_session_context(self, session_id: str) -> Dict[str, Any]:
        """获取会话上下文"""
        # 获取会话基本信息
        session_info = await self.redis.hgetall(f"session:{session_id}")
        if not session_info:
            return None

        # 获取消息历史
        messages = []
        message_list = await self.redis.lrange(f"session:{session_id}:messages", 0, -1)
        for msg in reversed(message_list):  # 反转以按时间顺序排列
            try:
                messages.append(json.loads(msg.decode()))
            except json.JSONDecodeError:
                pass

        # 获取上下文
        context = await self._get_session_context(session_id)

        return {
            "session_id": session_id,
            "user_id": int(session_info.get(b"user_id", b"0").decode()),
            "context": context,
            "message_count": int(session_info.get(b"message_count", b"0").decode()),
            "messages": messages,
            "created_at": session_info.get(b"created_at", b"").decode(),
            "updated_at": session_info.get(b"updated_at", b"").decode()
        }

    async def _get_session_context(self, session_id: str) -> Dict[str, Any]:
        """获取会话上下文"""
        context = await self.redis.hgetall(f"session:{session_id}:context")
        return {
            k.decode(): v.decode() for k, v in context.items()
        }

    async def delete_session(self, session_id: str, user_id: int) -> bool:
        """删除会话"""
        # 验证会话存在
        if not await self.redis.exists(f"session:{session_id}"):
            return False

        # 验证用户权限
        stored_user_id = await self.redis.hget(f"session:{session_id}", "user_id")
        if str(user_id) != stored_user_id:
            return False

        # 删除会话相关的所有键
        await self.redis.delete(f"session:{session_id}")
        await self.redis.delete(f"session:{session_id}:messages")
        await self.redis.delete(f"session:{session_id}:context")

        return True


# 单例模式
dialog_service_instance = None

def get_dialog_service() -> DialogService:
    """获取对话服务实例"""
    global dialog_service_instance
    if dialog_service_instance is None:
        dialog_service_instance = DialogService()
    return dialog_service_instance
```

### 7.3 智能体服务改造

```python
# app/agents/trip_planner_agent.py
"""
旅行规划智能体

负责：
- 处理用户对话
- 生成旅行建议
- 与后端服务交互
"""

import json
import asyncio
from typing import Dict, Any
from loguru import logger

from ..database.redis_client import get_redis_client


class ConversationalPlanner:
    def __init__(self, dialog_service):
        self.dialog_service = dialog_service
        self.redis = get_redis_client()
        self.message_queue = "queue:dialog:in"
        self.response_queue = "queue:dialog:out"

    async def chat(self, session_id: str, user_id: int, user_message: str) -> Dict[str, Any]:
        """处理对话"""
        # 这里应该是智能体的核心逻辑
        # 简化实现：直接返回一个模拟响应
        response = {
            "session_id": session_id,
            "message": f"我收到了你的消息: {user_message}",
            "intent": "general",
            "suggestions": ["你可以问我关于旅行的问题", "我可以帮你规划行程", "告诉我你想去的地方"]
        }

        return response

    async def start_agent_worker(self):
        """启动智能体工作线程"""
        logger.info("智能体工作线程启动")
        while True:
            try:
                # 从队列获取消息
                messages = await self.redis.xread(
                    {self.message_queue: "0"},
                    count=1,
                    block=1000
                )

                for stream, message_list in messages:
                    for message_id, message_data in message_list:
                        # 解析消息
                        session_id = message_data.get(b"session_id", b"").decode()
                        user_id = int(message_data.get(b"user_id", b"0").decode())
                        user_message = message_data.get(b"message", b"").decode()
                        context = json.loads(message_data.get(b"context", b"{}").decode())

                        logger.info(f"智能体处理消息: {session_id}")

                        # 处理消息
                        response = await self.chat(session_id, user_id, user_message)

                        # 发送响应到队列
                        await self.redis.xadd(
                            self.response_queue,
                            response,
                            maxlen=1000,
                            approximate=True
                        )

                        # 确认消息
                        await self.redis.xdel(self.message_queue, message_id)

            except Exception as e:
                logger.error(f"智能体工作线程错误: {str(e)}")

            await asyncio.sleep(0.1)


# 单例模式
conversational_planner_instance = None

def get_conversational_planner(dialog_service) -> ConversationalPlanner:
    """获取对话式规划器实例"""
    global conversational_planner_instance
    if conversational_planner_instance is None:
        conversational_planner_instance = ConversationalPlanner(dialog_service)
        # 启动工作线程
        asyncio.create_task(conversational_planner_instance.start_agent_worker())
    return conversational_planner_instance
```

## 8. 部署与集成

### 8.1 依赖安装

#### 后端依赖

```bash
pip install fastapi redis aioredis loguru uvicorn
```

#### 前端依赖

```bash
npm install eventsource
```

### 8.2 配置

#### Redis配置

在 `.env` 文件中添加Redis配置：

```env
REDIS_URL=redis://localhost:6379/0
REDIS_PASSWORD=
```

### 8.3 启动服务

1. **启动Redis服务**

2. **启动后端服务**

```bash
python run.py
```

3. **启动前端服务**

```bash
npm run dev
```

## 9. 测试计划

### 9.1 功能测试

1. **会话管理**：创建、列出、删除会话
2. **消息发送**：发送文本消息
3. **实时推送**：验证SSE推送功能
4. **历史对话**：查看历史对话记录
5. **队列功能**：验证消息队列的正常工作

### 9.2 性能测试

1. **响应时间**：测试消息响应时间
2. **并发测试**：测试多用户并发对话
3. **稳定性测试**：长时间运行测试

## 10. 总结

本设计文档详细描述了对话功能的改造方案，包括：

1. **架构设计**：采用四层级架构，使用SSE实现实时推送，使用Redis队列实现消息传递
2. **前端改造**：在Social.Vue页面左侧添加历史对话列表，右侧实现对话功能
3. **后端改造**：实现SSE端点，改造对话服务，添加队列操作
4. **智能体服务**：实现队列监听和消息处理
5. **数据存储**：使用Redis存储会话信息，默认保存7天

通过这些改造，对话功能将具备实时性、可靠性和可扩展性，为用户提供更好的对话体验。